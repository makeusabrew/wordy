What manages transitions between states on the client?

E.g. Auth -> do login -> enter lobby

Maybe we simplify it - in a typical MVC pattern we'd perhaps
redirect to /lobby - why not just emit a message of state:lobby
or perhaps call Client.setState("lobby")?

Need to clarify all communication paths - between client and
server but also individually (e.g. how controllers communicate
with each other, if at all)

Each side could have a global Bus object to allow 'vertical'
routing - if we consider client <-> server horizontal and communication
within a client or server vertical then the differentiation may be clearer:

Router / Routes: horizontal
Bus: vertical

Thus, responses to actions could either be horizontal emissions or vertical emissions...

This would cut down on a situation we currently have:

Client->Server:"auth:complete" # i'm done with auth, what's next? (never dictate expecation on client side)
Server->Client:"lobby:init"    # okay, your next move is lobby init, but since I'm the auth controller I can't be specific (decoupling)
Client->Server:"lobby:ready"   # i've done my init for lobby stuff, ready for some actual data...
Server->Client:"lobby:ready"   # here's the current lobby status: {...}

To:

Client->Server:"auth:complete" # i'm done with auth, what's next? (never dictate expecation on client side)
Server.Bus    :"lobby:init"    # server side bus emits relevant event; LobbyController picks it up
Server->Client:"lobby:ready"   # here's the current lobby status: {...}

Essentially, without an explicit event bus we're effectively just using the client/server sockets as one
instead.

Need to decide on naming conventions for socket 'routes' - when a client is done should it emit the
name of the action it just performed, or the name of the action it wants to perform next?
How do we distinguish between 'actions' (client requests something) and 'callbacks' (client responds
to something)?

Redis
-----

Can we use redis as the *only* datastore? No doubt it's possible, but what are the pros/cons of doing so?
I've already decided that it's a great fit for stuff like lobby users using sorted sets - which
actually would also be fantastic for high score lists etc too.

The other big advantage is not having any confusion over which data store took what sort of data - at
the moment MySQL Vs Redis is a developer decision. What would we store in redis? IDs, and hydrate
that data at fetch time from MySQL? That seems pointless and would be slower than just using MySQL
for joins.

When I started this project I had in mind half of it could be an experiment to try and use Redis as
the only data store - so why not? It can be easily made persistent, so no excuses there. All MySQL
offers is familiarity and an easy ability to query on different fields.

Using redis does require more up-front planning and could bite us if we need to 'query' data in
unexpected ways later on.

Ongoing events
--------------

Need to start planning how ongoing events will work; things not necessarily just triggered in reaction
to something (although the more I think about this the less I think this should ever actually happen).

Specifically, how do we spawn new games? What takes care of this? Had thought about something like a
GameManager - like a controller except its methods would not necessarily (or in fact at all) be
triggered by inbound routes / requests. Instead, a GameManager would be a singleton object which
could take any actions it saw fit - run loops, single timeouts, or respond to events on the bus.

It's this last case which is the most useful in reality. Thinking about it, the GameManager won't
ever want to just periodically spawn games; it'll always want to do so in reaction to an event:
a new user joining the lobby. To that end, why can't we just emit a "lobby:newuser" (or whatever)
event from the lobby controller, which the game manager can listen to?

Perhaps managers could be called proxies instead, and basically just hook up events to controllers
in much the same way as routers do?

This raises a potentially interesting design consideration: can we remove all @socket.emit "xxx"
from controllers altogether? Should they necessarily have access to a socket directly? On one hand
it's logical: a socket is analogous (ish, I think) to a request, and it's quite normal for a
controller to "know" about a request. On the other hand, this would mean a controller could simply
emit one event (e.g. "user:authed") which multiple things could listen to. The biggest downside
here is that of course one socket == one connection, so without the socket object within the
controller we couldn't easiy directly respond to the socket which triggered the request.

Next steps

# spawn game on user detection
# show game in lobby
# allow user to join game
# start game (based on some condition being met)
# spawn tiles
# ... good start :)

One thing I always fall foul of is knowing which controllers should handle which messages. Current
example:

    user in lobby clicks game, triggers "join game" message. Which backend controller picks
    this up? GameController or LobbyController? The User was/is *in* the lobby, but
    why should the lobby controller know anything about games?

Sockets
-------

Consider the scenario where a user joins the lobby. Do we use socket.io's rooms
or not? It would make sense to socket.join("room"), and indeed socket.join("game:id")
but it does place added burden on managing the socket's state on the server. Without
rooms we'll be sending more messages, but the clients could just ignore them if
they wished.

Another issue would be this:
# socket joins lobby
# emit lobby status to socket
# emit new user to those in lobby room

Obviously in this scenario the socket runs the risk of getting the initial
status of the lobby (which they're included in) AND then getting a second
message saying they've joined. Fine, so we re-order things:

# emit lobby status to socket
# emit new user to those in lobby room
# socket joins lobby

Something about this feels uncomfortable though, having such a strict
ordering. Also, we have to appreciate that rooms don't really help us
filter content on the client. For example, we can't just do:

sockets.in("lobby").emit("user:join")

And

sockets.in("game:123").emit("user:join")

Since then the *client* will have to track which room it's in in order
to know whether a "user:join" message applies to a lobby or a game state

Rooms do feel like they will be useful for games though, e.g. game:id,
since then we'll ensure that we don't send game traffic (of which we expect)
a lot to the wrong users. In fact this is where they do come in handy; this
means we can just have one set of routes, e.g. "game:gotpoints" which the
client will only pick up and apply to *their* game. In fact, this would
be impossible (or hard) **without** rooms since we bind all routes ahead
of time, so couldn't bind game:gotpoints:id (of course we could send the
ID with the message, which actually we will do).
